## NOTE: This schema was generated by Graphback and should not be changed manually

"""Exposes a URL that specifies the behaviour of this scalar."""
directive @specifiedBy(
  """The URL that specifies the behaviour of this scalar."""
  url: String!
) on SCALAR

input BooleanInput {
  ne: Boolean
  eq: Boolean
}

input CreateItemInput {
  position: Int
  completed: Boolean
  text: String
  itemId: GraphbackObjectID
}

input CreateNoteInput {
  title: String
  type: NoteTypes!
  version: Int!
  completed: Boolean
  text: String
}

scalar GraphbackObjectID

input GraphbackObjectIDInput {
  ne: GraphbackObjectID
  eq: GraphbackObjectID
  le: GraphbackObjectID
  lt: GraphbackObjectID
  ge: GraphbackObjectID
  gt: GraphbackObjectID
  in: [GraphbackObjectID!]
  between: [GraphbackObjectID!]
}

"""
The javascript `Date` as integer. Type represents date and time as number of milliseconds from start of UNIX epoch.
"""
scalar GraphbackTimestamp

input GraphbackTimestampInput {
  ne: GraphbackTimestamp
  eq: GraphbackTimestamp
  le: GraphbackTimestamp
  lt: GraphbackTimestamp
  ge: GraphbackTimestamp
  gt: GraphbackTimestamp
  in: [GraphbackTimestamp!]
  between: [GraphbackTimestamp!]
}

input IntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  in: [Int!]
  between: [Int!]
}

"""
@model
@datasync(
  ttl: 5184000
)
"""
type Item {
  _id: GraphbackObjectID!
  position: Int
  completed: Boolean
  text: String

  """@manyToOne(field: 'list', key: 'itemId')"""
  item: Note
}

input ItemFilter {
  _id: GraphbackObjectIDInput
  position: IntInput
  completed: BooleanInput
  text: StringInput
  itemId: GraphbackObjectIDInput
  and: [ItemFilter!]
  or: [ItemFilter!]
  not: ItemFilter
}

type ItemResultList {
  items: [Item]!
  offset: Int
  limit: Int
  count: Int
}

input ItemSubscriptionFilter {
  and: [ItemSubscriptionFilter!]
  or: [ItemSubscriptionFilter!]
  not: ItemSubscriptionFilter
  _id: GraphbackObjectIDInput
  position: IntInput
  completed: BooleanInput
  text: StringInput
}

input MutateItemInput {
  _id: GraphbackObjectID!
  position: Int
  completed: Boolean
  text: String
  itemId: GraphbackObjectID
}

input MutateNoteInput {
  _id: GraphbackObjectID!
  title: String
  type: NoteTypes
  version: Int
  completed: Boolean
  text: String
}

type Mutation {
  createNote(input: CreateNoteInput!): Note
  updateNote(input: MutateNoteInput!): Note
  deleteNote(input: MutateNoteInput!): Note
  createItem(input: CreateItemInput!): Item
  updateItem(input: MutateItemInput!): Item
  deleteItem(input: MutateItemInput!): Item
}

"""
@model
@versioned
@datasync(
  ttl: 5184000
)
"""
type Note {
  _id: GraphbackObjectID!
  title: String
  type: NoteTypes!
  version: Int!
  completed: Boolean
  text: String

  """
  @oneToMany(field: 'item', key: 'itemId')
  @db(type: 'json')
  @oneToMany(field: 'item')
  """
  list(filter: ItemFilter): [Item]

  """@createdAt"""
  createdAt: GraphbackTimestamp

  """@updatedAt"""
  updatedAt: GraphbackTimestamp
}

input NoteFilter {
  _id: GraphbackObjectIDInput
  title: StringInput
  type: StringInput
  version: IntInput
  completed: BooleanInput
  text: StringInput
  and: [NoteFilter!]
  or: [NoteFilter!]
  not: NoteFilter
  createdAt: GraphbackTimestampInput
  updatedAt: GraphbackTimestampInput
}

type NoteResultList {
  items: [Note]!
  offset: Int
  limit: Int
  count: Int
}

input NoteSubscriptionFilter {
  and: [NoteSubscriptionFilter!]
  or: [NoteSubscriptionFilter!]
  not: NoteSubscriptionFilter
  _id: GraphbackObjectIDInput
  title: StringInput
  type: StringInput
  version: IntInput
  completed: BooleanInput
  text: StringInput
}

enum NoteTypes {
  List
  Text
}

input OrderByInput {
  field: String!
  order: SortDirectionEnum = ASC
}

input PageRequest {
  limit: Int
  offset: Int
}

type Query {
  getDraftNotes: [Note]
  getNote(id: GraphbackObjectID!): Note
  findNotes(filter: NoteFilter, page: PageRequest, orderBy: OrderByInput): NoteResultList!
  getItem(id: GraphbackObjectID!): Item
  findItems(filter: ItemFilter, page: PageRequest, orderBy: OrderByInput): ItemResultList!
}

enum SortDirectionEnum {
  DESC
  ASC
}

input StringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  in: [String!]
  contains: String
  startsWith: String
  endsWith: String
}

type Subscription {
  newNote(filter: NoteSubscriptionFilter): Note!
  updatedNote(filter: NoteSubscriptionFilter): Note!
  deletedNote(filter: NoteSubscriptionFilter): Note!
  newItem(filter: ItemSubscriptionFilter): Item!
  updatedItem(filter: ItemSubscriptionFilter): Item!
  deletedItem(filter: ItemSubscriptionFilter): Item!
}